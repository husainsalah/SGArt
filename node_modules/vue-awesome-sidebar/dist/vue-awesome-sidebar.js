import { inject as M, unref as ee, openBlock as a, createBlock as I, resolveDynamicComponent as w, createElementBlock as h, mergeProps as X, toDisplayString as z, withCtx as te, createTextVNode as de, onBeforeUnmount as Z, resolveComponent as x, normalizeClass as y, normalizeStyle as O, createCommentVNode as m, createElementVNode as T, toHandlerKey as R, Fragment as S, renderList as J, toRefs as ie, ref as b, computed as Q, onMounted as fe, provide as v, watch as E, renderSlot as G, createVNode as ve, Transition as Me } from "vue";
const Ce = {
  props: ["data"]
}, ge = /* @__PURE__ */ Object.assign(Ce, {
  __name: "HeaderItem",
  setup(e) {
    const t = M("getSlotByName")("headerItem");
    return (i, u) => {
      var s, r, o;
      return ee(t) ? (a(), I(w(ee(t)), {
        key: 0,
        header: e.data.header
      }, null, 8, ["header"])) : (a(), h("div", X({
        key: 1,
        class: ["vsss-header", (s = e.data) != null && s.class ? (r = e.data) == null ? void 0 : r.class : ""]
      }, (o = e.data) == null ? void 0 : o.attributes), z(e.data.header), 17));
    };
  }
}), _ = (e, n) => {
  const t = e.__vccOpts || e;
  for (const [i, u] of n)
    t[i] = u;
  return t;
}, pe = {
  name: "MenuItemIcon",
  props: {
    icon: {
      default: ""
    }
  }
};
function Ie(e, n, t, i, u, s) {
  var r, o, c, d;
  return a(), I(w((r = t.icon) != null && r.element ? t.icon.element : "i"), X({
    class: ["menu-icon", (o = t.icon) != null && o.class ? (c = t.icon) == null ? void 0 : c.class : ""],
    "aria-hidden": "true"
  }, (d = t.icon) == null ? void 0 : d.attributes), {
    default: te(() => [
      de(z(t.icon.text), 1)
    ]),
    _: 1
  }, 16, ["class"]);
}
const ye = /* @__PURE__ */ _(pe, [["render", Ie]]), be = {
  name: "menu-item",
  components: { MenuItemIconVue: ye },
  data: () => ({
    showChildren: !1,
    expanded: !1,
    containerHeight: "0",
    hieghtTimeout: null,
    renderTimeOut: null,
    renderChildren: !1,
    cacheHieght: null,
    active: !1,
    miniActive: !1,
    hover: !1,
    ContainerOffsetY: 0,
    id: null,
    siblingsHaveIcon: !1,
    MakeSpace: !1,
    TopcontainerHiefht: "fit-content",
    labelMiniYofsset: 0,
    labelMiniYYofsset: 0,
    miniMenuOffset: 50,
    seTAnimationTimeOut: !1,
    topConTime: null
  }),
  props: [
    "smallMenu",
    "header",
    "depth",
    "siblingsHaveIconProp",
    "isParentFlat",
    "item",
    "isMakeSpace",
    "setMaxHeightTopCProp"
  ],
  setup() {
    const e = M("getSlotByName"), {
      animationDuration: n,
      menuType: t,
      widthMiniMenu: i,
      childrenOpenAnimation: u,
      removeIconSpace: s,
      vueRouterEnabel: r,
      keepChildrenOpen: o,
      checkButtonActive: c,
      ChildrenOpenActiveRoute: d,
      collapsed: l,
      position: g
    } = M("sidebarProps"), k = M("browserAgent"), f = M("currentRoute"), H = M("isSameUrl"), B = M("extractChildrenRoutes"), C = M("menuMounted"), j = M("miniMenu"), q = M("MenuScroll"), K = M("MenuHover"), Y = M("getRandomUid"), L = M("updateCurrantItemHover"), P = M("updateCurranContainerHover"), D = M("CurrantItemHover"), A = M("menuDirection"), N = M("emitOut"), F = M("updateIsCollapsed");
    let W = e("itemApendIcon"), U = e("itemPrepandIcon"), V = e("menuItemLabel");
    return {
      animationDuration: n,
      menuItemLabel: V,
      updateIsCollapsed: F,
      currentRoute: f,
      menuMounted: C,
      itemApendIcon: W,
      itemPrepandIcon: U,
      miniMenu: j,
      MenuScroll: q,
      MenuHover: K,
      keepChildrenOpen: o,
      ChildrenOpenActiveRoute: d,
      emitOut: N,
      menuDirection: A,
      checkButtonActive: c,
      CurrantItemHover: D,
      updateCurranContainerHover: P,
      updateCurrantItemHover: L,
      getRandomUid: Y,
      vueRouterEnabel: r,
      extractChildrenRoutes: B,
      isSameUrl: H,
      menuType: t,
      widthMiniMenu: i,
      childrenOpenAnimation: u,
      removeIconSpace: s,
      collapsed: l,
      userAgentHeight: k,
      position: g
    };
  },
  watch: {
    currentRoute() {
      this.checkActive();
    },
    collapsed(e) {
      e && this.miniMenu && this.depth === 0 && this.closeItemChildren();
    },
    hover() {
      this.miniMenu && this.hover, this.id || (this.id = this.getRandomUid()), this.hover ? (this.seTAnimationTimeOut = !0, this.updateCurrantItemHover(this.id), this.openItemCildren(), this.$nextTick(() => {
        setTimeout(() => {
          this.setItemOffsetHeight();
        }, 0);
        const e = this.$refs.labelRef.getBoundingClientRect();
        this.labelMiniYofsset = e[this.menuDirection], this.labelMiniYYofsset = e.top;
      })) : this.CurrantItemHover === this.id && this.MenuHover || this.closeItemChildren();
    },
    MenuHover() {
      this.MenuHover || this.closeItemChildren();
    },
    CurrantItemHover() {
      this.CurrantItemHover != this.id && this.closeItemChildren();
    },
    MenuScroll() {
      if (this.isMobile)
        this.closeItemChildren();
      else {
        this.setItemOffsetHeight();
        const e = this.$refs.labelRef.getBoundingClientRect();
        this.labelMiniYofsset = e[this.menuDirection], this.labelMiniYYofsset = e.top;
      }
    },
    miniMenu() {
      this.closeItemChildren(), this.$nextTick(() => {
        this.setItemOffsetHeight();
      });
    }
  },
  created() {
    this.checkActive();
  },
  mounted() {
    if (this.checkSiblingsForIcon(), this.setItemOffsetHeight(), this.position != "fixed") {
      const e = () => {
        if ("ontouchstart" in document.documentElement) {
          this.closeItemChildren();
          return;
        }
        this.setItemOffsetHeight();
        const t = this.$refs.labelRef.getBoundingClientRect();
        this.labelMiniYofsset = t[this.menuDirection], this.labelMiniYYofsset = t.top;
      }, n = () => {
        window.removeEventListener("scroll", e);
      };
      window.addEventListener("scroll", e), Z(n);
    }
  },
  computed: {
    isMobile() {
      return "ontouchstart" in document.documentElement;
    },
    miniActiveClass() {
      var e, n;
      return (e = this.item) != null && e.miniActiveClass ? (n = this.item) == null ? void 0 : n.miniActiveClass : "miniActive";
    },
    activeClass() {
      var e, n;
      return (e = this.item) != null && e.activeClass ? (n = this.item) == null ? void 0 : n.activeClass : "activeClass";
    },
    menuDirectionOposite() {
      return this.menuDirection === "right" ? "left" : "right";
    },
    labelName() {
      var e, n;
      return this.miniMenu ? this.depth != 0 ? (e = this.item) == null ? void 0 : e.name : !1 : (n = this.item) == null ? void 0 : n.name;
    },
    heifOfContainer() {
      return this.containerHeight === this.userAgentHeight ? this.containerHeight : this.containerHeight + "px";
    },
    transitionTime() {
      return `all ${this.animationDuration / 1e3}s ease-in-out`;
    },
    menuItemSlotData() {
      var e, n;
      return {
        icon: { icon: ((e = this.item) == null ? void 0 : e.icon) || {}, name: (n = this.item) == null ? void 0 : n.name }
      };
    },
    shouldMouseEnterEvent() {
      return this.miniMenu && this.depth == 0 ? "mouseover" : null;
    },
    keyOrClick() {
      return this.miniMenu && this.depth == 0 ? this.expanded ? this.isMobile ? "touchend" : "click" : this.isMobile ? "" : "click" : "click";
    },
    shouldMouseLeaveEvent() {
      return this.miniMenu && this.depth == 0 ? "mouseleave" : null;
    },
    ContainerOffsetYConputed() {
      return `${this.ContainerOffsetY}px`;
    },
    menuItemClass() {
      var n, t;
      let e = {};
      return e[`vas-${this.menuType}`] = !0, e[((n = this.item) == null ? void 0 : n.class) || ""] = (t = this.item) == null ? void 0 : t.class, {
        miniCollapseIconWidth: this.miniMenu && this.depth == 0,
        MenuItemWidthOnMiniCollapse: this.miniMenu && this.depth != 0,
        menuExpanded: this.menuType === "fully" && (!this.miniMenu && this.expanded && this.depth == 0 || this.miniMenu && this.depth == 1 && this.expanded),
        noIconWidth: this.removeIconSpace && !this.miniMenu && !this.siblingsHaveIconProp && this.isParentFlat,
        noIconwidthMiniMenu: this.removeIconSpace && this.miniMenu && this.depth != 0 && !this.siblingsHaveIconProp && this.isParentFlat,
        ...e
      };
    },
    miniLabelWidth() {
      const e = Number(this.menuType != "fully");
      return this.expanded ? `calc(${this.widthMiniMenu}*${e}/2 - ${this.$refs.menuItem.clientWidth}*${e}px/2 + ${this.$refs.menuItem.clientWidth}px + 250px - 1.5px)` : "35px";
    },
    miniLabelDirection() {
      return `calc((${this.widthMiniMenu} - ${this.miniMenuOffset}px) / 2)`;
    }
  },
  methods: {
    mousewheelop(e) {
      document.querySelector(".vas-menu").scrollBy(0, e.deltaY);
    },
    PushToTopOfCallStack(e) {
      setTimeout(() => {
        e();
      }, 0);
    },
    resloveHref(e) {
      return this != null && this.$router ? this.$router.resolve(e).href : e;
    },
    checkActive() {
      var n, t, i, u;
      if (!!this.checkButtonActive)
        if (((n = this.item) == null ? void 0 : n.href) && this.isSameUrl(this.resloveHref((t = this.item) == null ? void 0 : t.href)))
          this.active = !0, this.miniActive = !1;
        else {
          if (this.active = !1, !((i = this.item) != null && i.children))
            return;
          let s = !1, r = this.extractChildrenRoutes((u = this.item) == null ? void 0 : u.children, "href") || [];
          for (var e = 0; e < r.length; e++)
            if (this.isSameUrl(this.resloveHref(r[e]))) {
              if (s = !0, this.miniActive = !0, this.menuMounted || this.miniMenu)
                break;
              this.ChildrenOpenActiveRoute && this.openItemCildren();
              break;
            }
          this.miniActive = s;
        }
    },
    labelClick() {
      this.hover ? this.miniLabelClick() : this.toggleMenu();
    },
    clickCompose() {
      var e, n, t, i;
      (e = this.item) != null && e.collapseOnClick && this.updateIsCollapsed(!0), this.emitOut("item-click", this.item), this.vueRouterEnabel && ((n = this.item) == null ? void 0 : n.href) && this.$router && ((i = this.$router) == null || i.push((t = this.item) == null ? void 0 : t.href));
    },
    miniLabelClick() {
      this.clickCompose();
    },
    toggleMenu() {
      var e;
      this.clickCompose(), (e = this.item) != null && e.children && (clearTimeout(this.hieghtTimeout), clearTimeout(this.renderTimeOut), this.showChildren ? this.closeItemChildren() : this.openItemCildren());
    },
    setSmallMenuDataForToggle(e) {
      clearTimeout(this.topConTime), clearTimeout(this.hieghtTimeout), clearTimeout(this.renderTimeOut), this.$nextTick(() => {
        this.expanded = e;
      }), this.showChildren = e;
    },
    checkSiblingsForIcon() {
      var n, t, i, u;
      if (!(!this.removeIconSpace && this.menuType == "fully") && !!((n = this.item) != null && n.children)) {
        for (var e = 0; e < ((t = this.item) == null ? void 0 : t.children.length); e++)
          if ((u = (i = this.item) == null ? void 0 : i.children[e]) != null && u.icon) {
            this.siblingsHaveIcon = !0;
            break;
          }
      }
    },
    openItemCildren() {
      var e, n, t;
      this.depth === 1 && this.miniMenu && this.setMaxHeightTopCProp(), this.miniMenu && this.depth === 0 && (this.showChildren = !0, this.$nextTick(() => {
        this.expanded = !0;
      })), (e = this.item) != null && e.children && (this.expanded || (this.setSmallMenuDataForToggle(!0), this.renderChildren = !0, this.cacheHieght ? this.containerHeight = this.cacheHieght : this.containerHeight = this.menuMounted ? ((n = this.item) == null ? void 0 : n.children.length) * ((t = this.$refs.menuItem) == null ? void 0 : t.offsetHeight) + 3 : this.userAgentHeight, this.cacheHieght = null, this.menuMounted && (this.miniMenu && this.depth === 0 && (this.containerHeight = this.userAgentHeight), this.hieghtTimeout = setTimeout(
        () => {
          this.containerHeight = this.userAgentHeight;
        },
        this.childrenOpenAnimation ? this.animationDuration : 0
      ))));
    },
    closeItemChildren() {
      var e, n, t;
      if (this.seTAnimationTimeOut = !1, !this.menuCollapsed && this.miniMenu && this.depth === 0) {
        this.setSmallMenuDataForToggle(!1), this.topConTime = setTimeout(() => {
          this.containerHeight = 0, this.topConTime = null;
        }, this.animationDuration);
        return;
      }
      this.setSmallMenuDataForToggle(!1), (e = this.item) != null && e.children && (this.cacheHieght || (this.cacheHieght = (n = this.$refs.container) == null ? void 0 : n.offsetHeight), this.containerHeight = (t = this.$refs.container) == null ? void 0 : t.offsetHeight, this.PushToTopOfCallStack(() => {
      }), setTimeout(() => {
        this.$nextTick(() => {
          this.containerHeight = 0;
        });
      }, 10), !this.keepChildrenOpen && (this.renderTimeOut = setTimeout(
        () => {
          setTimeout(() => {
            this.renderChildren = !1;
          }, 20), this.cacheHieght = null;
        },
        this.childrenOpenAnimation ? this.animationDuration : 0
      )));
    },
    setMaxHeightTopC() {
      var n;
      const e = (n = this.$refs.topContainerRef) == null ? void 0 : n.getBoundingClientRect();
      this.MakeSpace ? this.TopcontainerHiefht = e.height + "px" : this.TopcontainerHiefht = e.height + innerHeight - (e.top + e.height) - 2 + "px";
    },
    setItemOffsetHeight() {
      var e, n, t;
      if (this.depth == 0) {
        const i = this.$refs.menuItem.getBoundingClientRect(), u = (e = this.$refs.topContainerRef) == null ? void 0 : e.getBoundingClientRect().height;
        let s = 0;
        (n = this.item) != null && n.children && (s = i.height * ((t = this.item) == null ? void 0 : t.children.length) + i.height), u && s + i.top - 15 > innerHeight ? (this.ContainerOffsetY = innerHeight - i.bottom, this.MakeSpace = !0) : (this.ContainerOffsetY = i.top, this.MakeSpace = !1), this.miniMenuOffset = i.width;
      }
    }
  }
}, ke = {
  key: 0,
  class: "BlockBack"
}, He = {
  key: 0,
  class: "labelName"
}, Oe = { key: 1 }, Se = { key: 1 }, we = {
  key: 0,
  class: "labelName"
}, Te = {
  key: 0,
  class: "labelminiSub"
}, Ae = {
  key: 2,
  class: "labelminiSub"
};
function Re(e, n, t, i, u, s) {
  var c, d, l, g, k;
  const r = x("MenuItemIconVue"), o = x("menu-item", !0);
  return a(), h("div", {
    class: y([s.menuItemClass, "menu-item-base alignCenter"]),
    ref: "menuItem",
    style: O({
      float: i.miniMenu && t.depth === 1 ? i.menuDirection : s.menuDirectionOposite
    })
  }, [
    e.active ? (a(), h("div", ke)) : m("", !0),
    T("div", {
      class: y(["label", {
        TransitionC: !i.miniMenu || i.miniMenu && !e.showChildren,
        menuexpand: e.showChildren,
        [s.activeClass]: e.active,
        [s.miniActiveClass]: e.miniActive,
        labelHoverClass: t.depth != 0 && i.miniMenu || !i.miniMenu
      }]),
      [R(s.shouldMouseEnterEvent)]: n[0] || (n[0] = (f) => this.hover = !0),
      [R(s.shouldMouseLeaveEvent)]: n[1] || (n[1] = (f) => this.hover = !1),
      [R(s.keyOrClick)]: n[2] || (n[2] = (...f) => s.labelClick && s.labelClick(...f)),
      style: O({
        [i.menuDirection == "left" ? "paddingLeft" : "paddingRight"]: i.menuType === "fully" ? `${t.depth * 18}px` : "",
        background: t.depth == 0 && !e.active && i.miniMenu ? "none" : ""
      })
    }, [
      T("div", {
        class: y(["left", { marginAuto: i.miniMenu && t.depth === 0, collapseEnd: i.miniMenu }]),
        ref: "labelRef"
      }, [
        !i.removeIconSpace || i.removeIconSpace && t.siblingsHaveIconProp ? (a(), h(S, { key: 0 }, [
          i.itemPrepandIcon ? i.itemPrepandIcon ? (a(), I(w(i.itemPrepandIcon), {
            key: 1,
            icon: (d = t.item) == null ? void 0 : d.icon,
            active: e.active,
            miniActive: e.miniActive,
            isChildrenMenuOpen: e.showChildren
          }, null, 8, ["icon", "active", "miniActive", "isChildrenMenuOpen"])) : m("", !0) : (a(), I(r, {
            key: 0,
            icon: (c = t.item) == null ? void 0 : c.icon
          }, null, 8, ["icon"]))
        ], 64)) : m("", !0),
        s.labelName ? (a(), h(S, { key: 1 }, [
          i.menuItemLabel ? (a(), I(w(i.menuItemLabel), {
            key: 1,
            labelName: s.labelName,
            active: e.active,
            miniActive: e.miniActive,
            isChildrenMenuOpen: e.showChildren
          }, null, 8, ["labelName", "active", "miniActive", "isChildrenMenuOpen"])) : (a(), h("span", He, z(s.labelName), 1))
        ], 64)) : m("", !0)
      ], 2),
      i.miniMenu && t.depth != 0 || !i.miniMenu ? (a(), h(S, { key: 0 }, [
        t.item.children && !i.itemApendIcon ? (a(), h("div", {
          key: 0,
          class: y(["icons postIconOpenAnima", { opened: e.showChildren }])
        }, null, 2)) : m("", !0),
        t.item.children && i.itemApendIcon ? (a(), h("div", Oe, [
          i.itemApendIcon ? (a(), I(w(i.itemApendIcon), {
            key: 0,
            icon: (l = t.item) == null ? void 0 : l.icon,
            isChildrenMenuOpen: e.showChildren,
            active: e.active,
            miniActive: e.miniActive
          }, null, 8, ["icon", "isChildrenMenuOpen", "active", "miniActive"])) : m("", !0)
        ])) : m("", !0)
      ], 64)) : m("", !0)
    ], 16),
    !i.miniMenu || t.depth != 0 && i.miniMenu ? (a(), h("div", Se, [
      t.item.children ? (a(), h("div", {
        key: 0,
        class: y(["items-container", { "small-menu": t.smallMenu }]),
        style: O({ maxHeight: s.heifOfContainer, transition: s.transitionTime }),
        ref: "container"
      }, [
        e.renderChildren ? (a(!0), h(S, { key: 0 }, J(t.item.children, (f, H) => (a(), I(o, {
          siblingsHaveIconProp: e.siblingsHaveIcon,
          isParentFlat: t.siblingsHaveIconProp,
          key: H,
          item: f,
          depth: t.depth + 1,
          smallMenu: t.smallMenu
        }, null, 8, ["siblingsHaveIconProp", "isParentFlat", "item", "depth", "smallMenu"]))), 128)) : m("", !0)
      ], 6)) : m("", !0)
    ])) : m("", !0),
    i.miniMenu && t.depth === 0 && !i.collapsed ? (a(), h("div", {
      key: 2,
      class: y({ topContainer: t.depth == 0, vasopacitiy: !e.expanded }),
      ref: "topContainerRef",
      style: O({
        [e.MakeSpace ? "bottom" : "top"]: `calc(${s.ContainerOffsetYConputed} - 1px)`,
        [i.menuDirection]: `calc(${i.widthMiniMenu} - 1px)`,
        maxHeight: e.TopcontainerHiefht,
        width: e.showChildren ? "250px" : "0px",
        zIndex: e.showChildren ? "850" : "849",
        animationDelay: e.seTAnimationTimeOut ? "0.3s" : "0"
      })
    }, [
      T("div", {
        onClick: n[3] || (n[3] = (...f) => s.miniLabelClick && s.miniLabelClick(...f)),
        onMousewheel: n[4] || (n[4] = (...f) => s.mousewheelop && s.mousewheelop(...f)),
        class: y(["labelMini", {
          [s.miniActiveClass]: e.miniActive,
          [s.activeClass]: e.active
        }]),
        style: O({
          position: "fixed",
          whiteSpace: "nowrap",
          [i.menuDirection]: i.menuType === "fully" ? "0px" : s.miniLabelDirection,
          width: s.miniLabelWidth,
          [e.MakeSpace ? "bottom" : "top"]: s.ContainerOffsetYConputed,
          opacity: t.depth === 0 && e.showChildren ? "1" : "0"
        })
      }, [
        e.showChildren ? (a(), h("div", {
          key: 0,
          class: y(["left", { marginAuto: i.miniMenu && t.depth === 0 }]),
          style: O({
            [i.menuDirection]: i.widthMiniMenu,
            top: e.labelMiniYYofsset + "px"
          })
        }, [
          i.menuItemLabel ? (a(), I(w(i.menuItemLabel), {
            key: 1,
            labelName: (k = t.item) == null ? void 0 : k.name,
            active: e.active,
            miniActive: e.miniActive,
            isChildrenMenuOpen: e.showChildren
          }, null, 8, ["labelName", "active", "miniActive", "isChildrenMenuOpen"])) : (a(), h("span", we, z((g = t.item) == null ? void 0 : g.name), 1))
        ], 6)) : m("", !0)
      ], 38),
      t.depth == 0 && !e.MakeSpace ? (a(), h("div", Te)) : m("", !0),
      t.item.children ? (a(), h("div", {
        key: 1,
        class: y(["items-container", { "small-menu": t.smallMenu }]),
        style: O({
          maxHeight: s.heifOfContainer,
          transition: s.transitionTime
        }),
        ref: "container"
      }, [
        e.renderChildren ? (a(!0), h(S, { key: 0 }, J(t.item.children, (f, H) => (a(), I(o, {
          siblingsHaveIconProp: e.siblingsHaveIcon,
          isParentFlat: t.siblingsHaveIconProp,
          key: H,
          item: f,
          depth: t.depth + 1,
          smallMenu: t.smallMenu,
          setMaxHeightTopCProp: s.setMaxHeightTopC,
          isMakeSpace: e.MakeSpace
        }, null, 8, ["siblingsHaveIconProp", "isParentFlat", "item", "depth", "smallMenu", "setMaxHeightTopCProp", "isMakeSpace"]))), 128)) : m("", !0)
      ], 6)) : m("", !0),
      t.depth == 0 && e.MakeSpace ? (a(), h("div", Ae)) : m("", !0)
    ], 6)) : m("", !0)
  ], 6);
}
const Be = /* @__PURE__ */ _(be, [["render", Re]]), Le = {
  name: "MenuHl",
  props: {
    data: {
      default: ""
    }
  }
};
function Pe(e, n, t, i, u, s) {
  var r, o, c, d;
  return a(), I(w((r = t.data) != null && r.element ? t.data.element : "hr"), X({
    class: ["vas-hr", (o = t.data) != null && o.class ? (c = t.data) == null ? void 0 : c.class : ""]
  }, (d = t.data) == null ? void 0 : d.attributes), null, 16, ["class"]);
}
const De = /* @__PURE__ */ _(Le, [["render", Pe]]), Ee = (e, n) => {
  const {
    menu: t,
    menuType: i,
    miniMenu: u,
    collapsed: s,
    animationDuration: r,
    width: o,
    widthMiniMenu: c,
    removeIconSpace: d,
    closeOnClickOutSide: l,
    overLayerOnOpen: g,
    childrenOpenAnimation: k,
    position: f,
    collapseBreakPoint: H,
    dark: B,
    vueRouterEnabel: C,
    keepChildrenOpen: j,
    checkButtonActive: q,
    ChildrenOpenActiveRoute: K,
    rtl: Y
  } = ie(e), L = b(s.value);
  b(n.slots);
  const P = b(!1), D = b(!1), A = b(u.value), N = b(!1), F = b(null), W = b(null), U = (p) => n.slots.hasOwnProperty(p) ? n.slots[p] : null, V = (p) => {
    L.value = p;
  }, ne = () => {
    D.value = !D.value;
  }, se = (p) => {
    N.value = p;
  }, ae = (p) => {
    F.value = p;
  }, le = (p) => {
    W.value = p;
  }, $ = Q(() => Y.value ? "right" : "left"), re = (p, me) => {
    n.emit(p, me);
  }, oe = (p) => {
    A.value = p;
  };
  let ue = navigator.userAgent.indexOf("Firefox") != -1 ? "-moz-max-content" : "fit-content", he = 3;
  const ce = () => he++;
  return fe(() => {
    P.value = !0;
  }), v("sidebarProps", {
    menu: t,
    menuType: i,
    collapsed: L,
    miniMenu: A,
    animationDuration: r,
    width: o,
    widthMiniMenu: c,
    removeIconSpace: d,
    closeOnClickOutSide: l,
    overLayerOnOpen: g,
    childrenOpenAnimation: k,
    position: f,
    collapseBreakPoint: H,
    vueRouterEnabel: C,
    checkButtonActive: q,
    ChildrenOpenActiveRoute: K,
    keepChildrenOpen: j,
    dark: B,
    rtl: Y
  }), v("getSlotByName", U), v("browserAgent", ue), v("menuMounted", P), v("miniMenu", A), v("MenuScroll", D), v("MenuHover", N), v("getRandomUid", ce), v("updateCurrantItemHover", ae), v("updateCurranContainerHover", le), v("CurrantItemHover", F), v("CurranContainerHover", W), v("menuDirection", $), v("updateIsCollapsed", V), v("emitOut", re), {
    getIsCollapsed: L,
    getIsminiMenu: A,
    updateIsCollapsed: V,
    getSlotByName: U,
    updateminiMenu: oe,
    menuMounted: P,
    updateMenuScroll: ne,
    updateMenuHover: se,
    menuDirection: $
  };
};
function xe(e, n, t) {
  if (!e)
    return;
  const i = (r) => {
    if (t.value) {
      u();
      return;
    }
    r.target == e.value || r.composedPath().includes(e.value) || n();
  }, u = () => {
    window.removeEventListener("click", i);
  }, s = () => {
    u(), setTimeout(() => {
      window.addEventListener("click", i);
    }, 0);
  };
  return Z(u), { removeSideBarListner: u, addSideBarListner: s };
}
function Ye(e, n) {
  if (!e)
    return;
  n(e > innerWidth);
  let t = window.innerWidth;
  const i = () => {
    t != window.innerWidth && (n(e > innerWidth), t = window.innerWidth);
  };
  window.addEventListener("resize", i), Z(() => {
    window.removeEventListener("resize", i);
  });
}
const Ne = (e, n) => {
  ie(e);
  const t = b(window.location);
  function i(r, o = t.value) {
    return o.href === o.origin + r || o.pathname + o.hash === r || o.pathname + o.search === r || o.href === r || o.hash === r;
  }
  function u(r, o) {
    if (!!r)
      return Object.entries(r).reduce(
        (c, [d, l]) => d === o ? c.concat(l) : typeof l == "object" ? c.concat(u(l, o)) : c,
        []
      );
  }
  const s = (r) => {
    t.value = { ...r };
  };
  return v("currentRoute", t), v("updateCurrentRoute", s), v("isSameUrl", i), v("extractChildrenRoutes", u), {
    isSameUrl: i,
    extractChildrenRoutes: u,
    currentRoute: t,
    updateCurrentRoute: s
  };
};
const Fe = {
  name: "vas-menu",
  props: {
    menu: {
      type: Array,
      required: !0
    },
    menuType: {
      type: String,
      default: "simple"
    },
    collapsed: {
      type: Boolean,
      default: !1
    },
    miniMenu: {
      type: Boolean,
      default: !1
    },
    animationDuration: {
      type: Number,
      default: 300
    },
    width: {
      type: String,
      default: "290px"
    },
    widthMiniMenu: {
      type: String,
      default: "65px"
    },
    autoCollapse: {
      type: Number,
      default: null
    },
    removeIconSpace: {
      type: Boolean,
      default: !1
    },
    closeOnClickOutSide: {
      type: Boolean,
      default: !1
    },
    overLayerOnOpen: {
      type: Boolean,
      default: !1
    },
    childrenOpenAnimation: {
      type: Boolean,
      default: !0
    },
    position: {
      type: String,
      default: "fixed"
    },
    keepChildrenOpen: {
      type: Boolean,
      default: !1
    },
    ChildrenOpenActiveRoute: {
      type: Boolean,
      default: !0
    },
    checkButtonActive: {
      type: Boolean,
      default: !0
    },
    vueRouterEnabel: {
      type: Boolean,
      default: !1
    },
    BottomMiniMenuBtn: {
      type: Boolean,
      default: !0
    },
    paddingTop: {
      type: String,
      default: "0px"
    },
    dark: {
      type: Boolean
    },
    rtl: {
      type: Boolean,
      default: !1
    }
  },
  emits: {
    "item-click"(e) {
      return !!e;
    },
    "update:collapsed"(e) {
      return typeof e == "boolean";
    },
    "update:miniMenu"(e) {
      return typeof e == "boolean";
    }
  },
  data: () => ({
    smallMenu: !1,
    siblingsHaveIcon: !1
  }),
  components: {
    MenuItem: Be,
    HeaderItem: ge,
    Menuline: De
  },
  mounted() {
    this.checkSiblingsForIcon(), window.addEventListener(
      "hashchange",
      () => {
        this.updateCurrentRoute(window.location);
      },
      !1
    );
  },
  watch: {
    async $route() {
      this.updateCurrentRoute(window.location);
    },
    miniMenuRef() {
      this.miniMenuRef && this.updateMenuHover(!0);
    }
  },
  computed: {
    menuScrollEvent() {
      return this.miniMenuRef ? "scroll" : null;
    },
    mouseEnterEvent() {
      return this.miniMenuRef ? "mouseenter" : null;
    },
    mouseLeaveEvent() {
      return this.miniMenuRef ? "mouseleave" : null;
    }
  },
  methods: {
    onMenuScroll() {
      this.updateMenuScroll();
    },
    onEnter() {
      this.updateMenuHover(!0);
    },
    onLeave() {
      this.updateMenuHover(!1);
    },
    checkSiblingsForIcon() {
      var n;
      if (!(!this.removeIconSpace && this.menuType == "fully")) {
        for (var e = 0; e < this.menu.length; e++)
          if ((n = this.menu[e]) != null && n.icon) {
            this.siblingsHaveIcon = !0;
            break;
          }
      }
    },
    toggleMiniCollapse() {
      const e = !this.miniMenuRef;
      this.updateminiMenu(e), this.$emit("update:miniMenu", e);
    }
  },
  setup(e, n) {
    const {
      getIsCollapsed: t,
      getIsminiMenu: i,
      updateMenuScroll: u,
      updateMenuHover: s,
      updateminiMenu: r,
      menuDirection: o,
      updateIsCollapsed: c
    } = Ee(e, n), { updateCurrentRoute: d } = Ne(e), l = b(null), g = b(e.overLayerOnOpen), { removeSideBarListner: k, addSideBarListner: f } = xe(
      l,
      () => {
        c(!t.value);
      },
      t
    );
    e.closeOnClickOutSide && f(), E(
      () => t.value,
      (C) => {
        n.emit("update:collapsed", C), e.overLayerOnOpen && (g.value = !C), e.closeOnClickOutSide && (C ? k() : f());
      }
    ), E(
      () => e.collapsed,
      (C) => {
        c(C);
      }
    ), E(
      () => e.closeOnClickOutSide,
      (C) => {
        C ? f() : k();
      }
    ), E(
      () => e.miniMenu,
      (C) => {
        r(C);
      }
    ), E(
      () => e.overLayerOnOpen,
      (C) => {
        C ? g.value = !t.value : g.value = !1;
      }
    );
    const H = Q(() => i.value ? e.widthMiniMenu : e.width), B = Q(() => [
      `${e.dark ? "dark" : "white"}-theme`,
      e.rtl ? "rtl" : "ltr"
    ]);
    return Ye(e.autoCollapse, c), e.overLayerOnOpen && (g.value = !t.value), {
      sidebarMenuWidth: H,
      updateMenuScroll: u,
      sidebarClass: B,
      sidebarmen: l,
      updateCurrentRoute: d,
      updateMenuHover: s,
      overLayer: g,
      isCollapsed: t,
      updateminiMenu: r,
      miniMenuRef: i,
      menuDirection: o
    };
  }
}, We = { class: "vas-footer" }, Ue = /* @__PURE__ */ T("div", { class: "footer-wrapper" }, null, -1), Ve = {
  key: 0,
  class: "vas-over-layer"
};
function ze(e, n, t, i, u, s) {
  var d;
  const r = x("MenuItem"), o = x("HeaderItem"), c = x("Menuline");
  return a(), h(S, null, [
    T("nav", {
      class: y(["vas-menu", i.sidebarClass]),
      ref: "sidebarmen",
      style: O([{
        width: i.sidebarMenuWidth,
        position: t.position,
        [i.menuDirection]: i.isCollapsed ? `calc(-1*(${i.sidebarMenuWidth} + 2px))` : "0px",
        direction: t.rtl ? "rtl" : "ltr",
        paddingTop: t.paddingTop
      }, { overflow: "hidden" }]),
      [R(s.mouseEnterEvent)]: n[2] || (n[2] = (...l) => s.onEnter && s.onEnter(...l)),
      [R(s.mouseLeaveEvent)]: n[3] || (n[3] = (...l) => s.onLeave && s.onLeave(...l))
    }, [
      T("div", {
        [R(s.menuScrollEvent)]: n[0] || (n[0] = (...l) => s.onMenuScroll && s.onMenuScroll(...l)),
        class: y(["menu-wraper", {
          miniCoolapseMenu: i.miniMenuRef,
          compeleteCoolapseMenu: i.isCollapsed
        }]),
        style: O({
          width: i.sidebarMenuWidth
        })
      }, [
        G(e.$slots, "header"),
        (a(!0), h(S, null, J(t.menu, (l, g) => (a(), h(S, { key: g }, [
          !(l != null && l.header) && !(l != null && l.LineShow) ? (a(), I(r, {
            key: 0,
            item: l,
            depth: 0,
            smallMenu: e.smallMenu,
            siblingsHaveIconProp: e.siblingsHaveIcon
          }, null, 8, ["item", "smallMenu", "siblingsHaveIconProp"])) : (l == null ? void 0 : l.header) && !i.miniMenuRef ? (a(), I(o, {
            key: 1,
            data: l
          }, null, 8, ["data"])) : l != null && l.LineShow ? (a(), I(c, {
            key: 2,
            data: l
          }, null, 8, ["data"])) : m("", !0)
        ], 64))), 128)),
        T("div", We, [
          Ue,
          G(e.$slots, "footer")
        ])
      ], 16),
      t.BottomMiniMenuBtn ? (a(), h("div", {
        key: 0,
        class: "bottomBtn",
        onClick: n[1] || (n[1] = (...l) => s.toggleMiniCollapse && s.toggleMiniCollapse(...l))
      }, [
        (d = e.$slots) != null && d.BottomMiniMenuBtn ? G(e.$slots, "BottomMiniMenuBtn", {
          key: 1,
          miniMenu: i.miniMenuRef
        }) : (a(), h("div", {
          key: 0,
          class: y(["icons bottomBtnIcon", { ssdSpin: !i.miniMenuRef }])
        }, null, 2))
      ])) : m("", !0)
    ], 16),
    ve(Me, { name: "vas-fade" }, {
      default: te(() => [
        i.overLayer ? (a(), h("div", Ve)) : m("", !0)
      ]),
      _: 1
    })
  ], 64);
}
const _e = /* @__PURE__ */ _(Fe, [["render", ze]]), qe = {
  install: (e) => {
    e.component("VueAwesomeSideBar", _e);
  }
};
export {
  _e as VueAwesomeSideBar,
  qe as default
};
//# sourceMappingURL=vue-awesome-sidebar.js.map
